// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// SportTypeManagerClient is the client API for SportTypeManager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SportTypeManagerClient interface {
	CreateSportType(ctx context.Context, in *CreateSportTypeRequest, opts ...grpc.CallOption) (*SportType, error)
	GetSportType(ctx context.Context, in *GetSportTypeRequest, opts ...grpc.CallOption) (*SportType, error)
	UpdateSportType(ctx context.Context, in *UpdateSportTypeRequest, opts ...grpc.CallOption) (*SportType, error)
	DeleteSportType(ctx context.Context, in *DeleteSportTypeRequest, opts ...grpc.CallOption) (*SportType, error)
	GetSportTypes(ctx context.Context, in *GetSportTypesRequest, opts ...grpc.CallOption) (*GetSportTypesReply, error)
}

type sportTypeManagerClient struct {
	cc grpc.ClientConnInterface
}

func NewSportTypeManagerClient(cc grpc.ClientConnInterface) SportTypeManagerClient {
	return &sportTypeManagerClient{cc}
}

func (c *sportTypeManagerClient) CreateSportType(ctx context.Context, in *CreateSportTypeRequest, opts ...grpc.CallOption) (*SportType, error) {
	out := new(SportType)
	err := c.cc.Invoke(ctx, "/pb.SportTypeManager/CreateSportType", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sportTypeManagerClient) GetSportType(ctx context.Context, in *GetSportTypeRequest, opts ...grpc.CallOption) (*SportType, error) {
	out := new(SportType)
	err := c.cc.Invoke(ctx, "/pb.SportTypeManager/GetSportType", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sportTypeManagerClient) UpdateSportType(ctx context.Context, in *UpdateSportTypeRequest, opts ...grpc.CallOption) (*SportType, error) {
	out := new(SportType)
	err := c.cc.Invoke(ctx, "/pb.SportTypeManager/UpdateSportType", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sportTypeManagerClient) DeleteSportType(ctx context.Context, in *DeleteSportTypeRequest, opts ...grpc.CallOption) (*SportType, error) {
	out := new(SportType)
	err := c.cc.Invoke(ctx, "/pb.SportTypeManager/DeleteSportType", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sportTypeManagerClient) GetSportTypes(ctx context.Context, in *GetSportTypesRequest, opts ...grpc.CallOption) (*GetSportTypesReply, error) {
	out := new(GetSportTypesReply)
	err := c.cc.Invoke(ctx, "/pb.SportTypeManager/GetSportTypes", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SportTypeManagerServer is the server API for SportTypeManager service.
// All implementations must embed UnimplementedSportTypeManagerServer
// for forward compatibility
type SportTypeManagerServer interface {
	CreateSportType(context.Context, *CreateSportTypeRequest) (*SportType, error)
	GetSportType(context.Context, *GetSportTypeRequest) (*SportType, error)
	UpdateSportType(context.Context, *UpdateSportTypeRequest) (*SportType, error)
	DeleteSportType(context.Context, *DeleteSportTypeRequest) (*SportType, error)
	GetSportTypes(context.Context, *GetSportTypesRequest) (*GetSportTypesReply, error)
	mustEmbedUnimplementedSportTypeManagerServer()
}

// UnimplementedSportTypeManagerServer must be embedded to have forward compatible implementations.
type UnimplementedSportTypeManagerServer struct {
}

func (UnimplementedSportTypeManagerServer) CreateSportType(context.Context, *CreateSportTypeRequest) (*SportType, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSportType not implemented")
}
func (UnimplementedSportTypeManagerServer) GetSportType(context.Context, *GetSportTypeRequest) (*SportType, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSportType not implemented")
}
func (UnimplementedSportTypeManagerServer) UpdateSportType(context.Context, *UpdateSportTypeRequest) (*SportType, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSportType not implemented")
}
func (UnimplementedSportTypeManagerServer) DeleteSportType(context.Context, *DeleteSportTypeRequest) (*SportType, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSportType not implemented")
}
func (UnimplementedSportTypeManagerServer) GetSportTypes(context.Context, *GetSportTypesRequest) (*GetSportTypesReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSportTypes not implemented")
}
func (UnimplementedSportTypeManagerServer) mustEmbedUnimplementedSportTypeManagerServer() {}

// UnsafeSportTypeManagerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SportTypeManagerServer will
// result in compilation errors.
type UnsafeSportTypeManagerServer interface {
	mustEmbedUnimplementedSportTypeManagerServer()
}

func RegisterSportTypeManagerServer(s grpc.ServiceRegistrar, srv SportTypeManagerServer) {
	s.RegisterService(&SportTypeManager_ServiceDesc, srv)
}

func _SportTypeManager_CreateSportType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSportTypeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SportTypeManagerServer).CreateSportType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.SportTypeManager/CreateSportType",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SportTypeManagerServer).CreateSportType(ctx, req.(*CreateSportTypeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SportTypeManager_GetSportType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSportTypeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SportTypeManagerServer).GetSportType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.SportTypeManager/GetSportType",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SportTypeManagerServer).GetSportType(ctx, req.(*GetSportTypeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SportTypeManager_UpdateSportType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSportTypeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SportTypeManagerServer).UpdateSportType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.SportTypeManager/UpdateSportType",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SportTypeManagerServer).UpdateSportType(ctx, req.(*UpdateSportTypeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SportTypeManager_DeleteSportType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSportTypeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SportTypeManagerServer).DeleteSportType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.SportTypeManager/DeleteSportType",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SportTypeManagerServer).DeleteSportType(ctx, req.(*DeleteSportTypeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SportTypeManager_GetSportTypes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSportTypesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SportTypeManagerServer).GetSportTypes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.SportTypeManager/GetSportTypes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SportTypeManagerServer).GetSportTypes(ctx, req.(*GetSportTypesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SportTypeManager_ServiceDesc is the grpc.ServiceDesc for SportTypeManager service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SportTypeManager_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.SportTypeManager",
	HandlerType: (*SportTypeManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateSportType",
			Handler:    _SportTypeManager_CreateSportType_Handler,
		},
		{
			MethodName: "GetSportType",
			Handler:    _SportTypeManager_GetSportType_Handler,
		},
		{
			MethodName: "UpdateSportType",
			Handler:    _SportTypeManager_UpdateSportType_Handler,
		},
		{
			MethodName: "DeleteSportType",
			Handler:    _SportTypeManager_DeleteSportType_Handler,
		},
		{
			MethodName: "GetSportTypes",
			Handler:    _SportTypeManager_GetSportTypes_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sport_type.proto",
}
