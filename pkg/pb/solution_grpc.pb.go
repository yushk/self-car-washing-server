// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// SolutionManagerClient is the client API for SolutionManager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SolutionManagerClient interface {
	CreateSolution(ctx context.Context, in *CreateSolutionRequest, opts ...grpc.CallOption) (*Solution, error)
	GetSolution(ctx context.Context, in *GetSolutionRequest, opts ...grpc.CallOption) (*Solution, error)
	UpdateSolution(ctx context.Context, in *UpdateSolutionRequest, opts ...grpc.CallOption) (*Solution, error)
	DeleteSolution(ctx context.Context, in *DeleteSolutionRequest, opts ...grpc.CallOption) (*Solution, error)
	GetSolutions(ctx context.Context, in *GetSolutionsRequest, opts ...grpc.CallOption) (*GetSolutionsReply, error)
}

type solutionManagerClient struct {
	cc grpc.ClientConnInterface
}

func NewSolutionManagerClient(cc grpc.ClientConnInterface) SolutionManagerClient {
	return &solutionManagerClient{cc}
}

func (c *solutionManagerClient) CreateSolution(ctx context.Context, in *CreateSolutionRequest, opts ...grpc.CallOption) (*Solution, error) {
	out := new(Solution)
	err := c.cc.Invoke(ctx, "/pb.SolutionManager/CreateSolution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *solutionManagerClient) GetSolution(ctx context.Context, in *GetSolutionRequest, opts ...grpc.CallOption) (*Solution, error) {
	out := new(Solution)
	err := c.cc.Invoke(ctx, "/pb.SolutionManager/GetSolution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *solutionManagerClient) UpdateSolution(ctx context.Context, in *UpdateSolutionRequest, opts ...grpc.CallOption) (*Solution, error) {
	out := new(Solution)
	err := c.cc.Invoke(ctx, "/pb.SolutionManager/UpdateSolution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *solutionManagerClient) DeleteSolution(ctx context.Context, in *DeleteSolutionRequest, opts ...grpc.CallOption) (*Solution, error) {
	out := new(Solution)
	err := c.cc.Invoke(ctx, "/pb.SolutionManager/DeleteSolution", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *solutionManagerClient) GetSolutions(ctx context.Context, in *GetSolutionsRequest, opts ...grpc.CallOption) (*GetSolutionsReply, error) {
	out := new(GetSolutionsReply)
	err := c.cc.Invoke(ctx, "/pb.SolutionManager/GetSolutions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SolutionManagerServer is the server API for SolutionManager service.
// All implementations must embed UnimplementedSolutionManagerServer
// for forward compatibility
type SolutionManagerServer interface {
	CreateSolution(context.Context, *CreateSolutionRequest) (*Solution, error)
	GetSolution(context.Context, *GetSolutionRequest) (*Solution, error)
	UpdateSolution(context.Context, *UpdateSolutionRequest) (*Solution, error)
	DeleteSolution(context.Context, *DeleteSolutionRequest) (*Solution, error)
	GetSolutions(context.Context, *GetSolutionsRequest) (*GetSolutionsReply, error)
	mustEmbedUnimplementedSolutionManagerServer()
}

// UnimplementedSolutionManagerServer must be embedded to have forward compatible implementations.
type UnimplementedSolutionManagerServer struct {
}

func (UnimplementedSolutionManagerServer) CreateSolution(context.Context, *CreateSolutionRequest) (*Solution, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSolution not implemented")
}
func (UnimplementedSolutionManagerServer) GetSolution(context.Context, *GetSolutionRequest) (*Solution, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSolution not implemented")
}
func (UnimplementedSolutionManagerServer) UpdateSolution(context.Context, *UpdateSolutionRequest) (*Solution, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSolution not implemented")
}
func (UnimplementedSolutionManagerServer) DeleteSolution(context.Context, *DeleteSolutionRequest) (*Solution, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSolution not implemented")
}
func (UnimplementedSolutionManagerServer) GetSolutions(context.Context, *GetSolutionsRequest) (*GetSolutionsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSolutions not implemented")
}
func (UnimplementedSolutionManagerServer) mustEmbedUnimplementedSolutionManagerServer() {}

// UnsafeSolutionManagerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SolutionManagerServer will
// result in compilation errors.
type UnsafeSolutionManagerServer interface {
	mustEmbedUnimplementedSolutionManagerServer()
}

func RegisterSolutionManagerServer(s grpc.ServiceRegistrar, srv SolutionManagerServer) {
	s.RegisterService(&SolutionManager_ServiceDesc, srv)
}

func _SolutionManager_CreateSolution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSolutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SolutionManagerServer).CreateSolution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.SolutionManager/CreateSolution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SolutionManagerServer).CreateSolution(ctx, req.(*CreateSolutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SolutionManager_GetSolution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSolutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SolutionManagerServer).GetSolution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.SolutionManager/GetSolution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SolutionManagerServer).GetSolution(ctx, req.(*GetSolutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SolutionManager_UpdateSolution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSolutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SolutionManagerServer).UpdateSolution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.SolutionManager/UpdateSolution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SolutionManagerServer).UpdateSolution(ctx, req.(*UpdateSolutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SolutionManager_DeleteSolution_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSolutionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SolutionManagerServer).DeleteSolution(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.SolutionManager/DeleteSolution",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SolutionManagerServer).DeleteSolution(ctx, req.(*DeleteSolutionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SolutionManager_GetSolutions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSolutionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SolutionManagerServer).GetSolutions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.SolutionManager/GetSolutions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SolutionManagerServer).GetSolutions(ctx, req.(*GetSolutionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SolutionManager_ServiceDesc is the grpc.ServiceDesc for SolutionManager service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SolutionManager_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "pb.SolutionManager",
	HandlerType: (*SolutionManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateSolution",
			Handler:    _SolutionManager_CreateSolution_Handler,
		},
		{
			MethodName: "GetSolution",
			Handler:    _SolutionManager_GetSolution_Handler,
		},
		{
			MethodName: "UpdateSolution",
			Handler:    _SolutionManager_UpdateSolution_Handler,
		},
		{
			MethodName: "DeleteSolution",
			Handler:    _SolutionManager_DeleteSolution_Handler,
		},
		{
			MethodName: "GetSolutions",
			Handler:    _SolutionManager_GetSolutions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "solution.proto",
}
